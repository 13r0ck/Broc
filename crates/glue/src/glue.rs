// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `broc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Types {
    pub aligns: broc_std::BrocList<u32>,
    pub deps: broc_std::BrocDict<u32, broc_std::BrocList<u32>>,
    pub sizes: broc_std::BrocList<u32>,
    pub types: broc_std::BrocList<BrocType>,
    pub typesByName: broc_std::BrocDict<broc_std::BrocStr, u32>,
    pub target: Target,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_BrocType {
    Bool = 0,
    EmptyTagUnion = 1,
    Function = 2,
    Num = 3,
    RecursivePointer = 4,
    BrocBox = 5,
    BrocDict = 6,
    BrocList = 7,
    BrocResult = 8,
    BrocSet = 9,
    BrocStr = 10,
    Struct = 11,
    TagUnion = 12,
    TagUnionPayload = 13,
    Unit = 14,
}

impl core::fmt::Debug for discriminant_BrocType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Bool => f.write_str("discriminant_BrocType::Bool"),
            Self::EmptyTagUnion => f.write_str("discriminant_BrocType::EmptyTagUnion"),
            Self::Function => f.write_str("discriminant_BrocType::Function"),
            Self::Num => f.write_str("discriminant_BrocType::Num"),
            Self::RecursivePointer => f.write_str("discriminant_BrocType::RecursivePointer"),
            Self::BrocBox => f.write_str("discriminant_BrocType::BrocBox"),
            Self::BrocDict => f.write_str("discriminant_BrocType::BrocDict"),
            Self::BrocList => f.write_str("discriminant_BrocType::BrocList"),
            Self::BrocResult => f.write_str("discriminant_BrocType::BrocResult"),
            Self::BrocSet => f.write_str("discriminant_BrocType::BrocSet"),
            Self::BrocStr => f.write_str("discriminant_BrocType::BrocStr"),
            Self::Struct => f.write_str("discriminant_BrocType::Struct"),
            Self::TagUnion => f.write_str("discriminant_BrocType::TagUnion"),
            Self::TagUnionPayload => f.write_str("discriminant_BrocType::TagUnionPayload"),
            Self::Unit => f.write_str("discriminant_BrocType::Unit"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union BrocType {
    Function: core::mem::ManuallyDrop<R1>,
    Num: BrocNum,
    RecursivePointer: u32,
    BrocBox: u32,
    BrocDict: BrocType_BrocDict,
    BrocList: u32,
    BrocResult: BrocType_BrocResult,
    BrocSet: u32,
    Struct: core::mem::ManuallyDrop<R2>,
    TagUnion: core::mem::ManuallyDrop<BrocTagUnion>,
    TagUnionPayload: core::mem::ManuallyDrop<R14>,
    _sizer: [u8; 52],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R15 {
    pub discriminant: u32,
    pub r#type: u32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R12 {
    pub name: broc_std::BrocStr,
    pub payload: U4,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R10 {
    pub name: broc_std::BrocStr,
    pub payload: U3,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R7 {
    pub name: broc_std::BrocStr,
    pub payload: U1,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R3 {
    pub name: broc_std::BrocStr,
    pub r#type: u32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Target {
    pub architecture: Architecture,
    pub operatingSystem: OperatingSystem,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum OperatingSystem {
    Unix = 0,
    Wasi = 1,
    Windows = 2,
}

impl core::fmt::Debug for OperatingSystem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Unix => f.write_str("OperatingSystem::Unix"),
            Self::Wasi => f.write_str("OperatingSystem::Wasi"),
            Self::Windows => f.write_str("OperatingSystem::Windows"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum Architecture {
    Aarch32 = 0,
    Aarch64 = 1,
    Wasm32 = 2,
    X86x32 = 3,
    X86x64 = 4,
}

impl core::fmt::Debug for Architecture {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Aarch32 => f.write_str("Architecture::Aarch32"),
            Self::Aarch64 => f.write_str("Architecture::Aarch64"),
            Self::Wasm32 => f.write_str("Architecture::Wasm32"),
            Self::X86x32 => f.write_str("Architecture::X86x32"),
            Self::X86x64 => f.write_str("Architecture::X86x64"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R14 {
    pub fields: broc_std::BrocList<R15>,
    pub name: broc_std::BrocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_BrocTagUnion {
    Enumeration = 0,
    NonNullableUnwrapped = 1,
    NonRecursive = 2,
    NullableUnwrapped = 3,
    NullableWrapped = 4,
    Recursive = 5,
    SingleTagStruct = 6,
}

impl core::fmt::Debug for discriminant_BrocTagUnion {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Enumeration => f.write_str("discriminant_BrocTagUnion::Enumeration"),
            Self::NonNullableUnwrapped => f.write_str("discriminant_BrocTagUnion::NonNullableUnwrapped"),
            Self::NonRecursive => f.write_str("discriminant_BrocTagUnion::NonRecursive"),
            Self::NullableUnwrapped => f.write_str("discriminant_BrocTagUnion::NullableUnwrapped"),
            Self::NullableWrapped => f.write_str("discriminant_BrocTagUnion::NullableWrapped"),
            Self::Recursive => f.write_str("discriminant_BrocTagUnion::Recursive"),
            Self::SingleTagStruct => f.write_str("discriminant_BrocTagUnion::SingleTagStruct"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union BrocTagUnion {
    Enumeration: core::mem::ManuallyDrop<R4>,
    NonNullableUnwrapped: core::mem::ManuallyDrop<R5>,
    NonRecursive: core::mem::ManuallyDrop<R6>,
    NullableUnwrapped: core::mem::ManuallyDrop<R8>,
    NullableWrapped: core::mem::ManuallyDrop<R9>,
    Recursive: core::mem::ManuallyDrop<R11>,
    SingleTagStruct: core::mem::ManuallyDrop<R13>,
    _sizer: [u8; 48],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R13 {
    pub name: broc_std::BrocStr,
    pub payloadFields: broc_std::BrocList<u32>,
    pub tagName: broc_std::BrocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R11 {
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
    pub name: broc_std::BrocStr,
    pub tags: broc_std::BrocList<R12>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U4 {
    None = 0,
    Some = 1,
}

impl core::fmt::Debug for discriminant_U4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::None => f.write_str("discriminant_U4::None"),
            Self::Some => f.write_str("discriminant_U4::Some"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union U4 {
    Some: u32,
    _sizer: [u8; 8],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R9 {
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
    pub name: broc_std::BrocStr,
    pub tags: broc_std::BrocList<R10>,
    pub indexOfNullTag: u16,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U3 {
    None = 0,
    Some = 1,
}

impl core::fmt::Debug for discriminant_U3 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::None => f.write_str("discriminant_U3::None"),
            Self::Some => f.write_str("discriminant_U3::Some"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union U3 {
    Some: u32,
    _sizer: [u8; 8],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R8 {
    pub name: broc_std::BrocStr,
    pub nonNullPayload: u32,
    pub nonNullTag: broc_std::BrocStr,
    pub nullTag: broc_std::BrocStr,
    pub whichTagIsNull: U2,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum U2 {
    FirstTagIsNull = 0,
    SecondTagIsNull = 1,
}

impl core::fmt::Debug for U2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::FirstTagIsNull => f.write_str("U2::FirstTagIsNull"),
            Self::SecondTagIsNull => f.write_str("U2::SecondTagIsNull"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R6 {
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
    pub name: broc_std::BrocStr,
    pub tags: broc_std::BrocList<R7>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U1 {
    None = 0,
    Some = 1,
}

impl core::fmt::Debug for discriminant_U1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::None => f.write_str("discriminant_U1::None"),
            Self::Some => f.write_str("discriminant_U1::Some"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union U1 {
    Some: u32,
    _sizer: [u8; 8],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R5 {
    pub name: broc_std::BrocStr,
    pub payload: u32,
    pub tagName: broc_std::BrocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R4 {
    pub name: broc_std::BrocStr,
    pub size: u32,
    pub tags: broc_std::BrocList<broc_std::BrocStr>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R2 {
    pub fields: broc_std::BrocList<R3>,
    pub name: broc_std::BrocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct BrocType_BrocResult {
    pub f0: u32,
    pub f1: u32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct BrocType_BrocDict {
    pub f0: u32,
    pub f1: u32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum BrocNum {
    Dec = 0,
    F32 = 2,
    F64 = 3,
    I128 = 4,
    I16 = 5,
    I32 = 6,
    I64 = 7,
    I8 = 8,
    U128 = 9,
    U16 = 10,
    U32 = 11,
    U64 = 12,
    U8 = 13,
}

impl core::fmt::Debug for BrocNum {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Dec => f.write_str("BrocNum::Dec"),
            Self::F32 => f.write_str("BrocNum::F32"),
            Self::F64 => f.write_str("BrocNum::F64"),
            Self::I128 => f.write_str("BrocNum::I128"),
            Self::I16 => f.write_str("BrocNum::I16"),
            Self::I32 => f.write_str("BrocNum::I32"),
            Self::I64 => f.write_str("BrocNum::I64"),
            Self::I8 => f.write_str("BrocNum::I8"),
            Self::U128 => f.write_str("BrocNum::U128"),
            Self::U16 => f.write_str("BrocNum::U16"),
            Self::U32 => f.write_str("BrocNum::U32"),
            Self::U64 => f.write_str("BrocNum::U64"),
            Self::U8 => f.write_str("BrocNum::U8"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R1 {
    pub args: broc_std::BrocList<u32>,
    pub name: broc_std::BrocStr,
    pub ret: u32,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Types {
    pub aligns: broc_std::BrocList<u32>,
    pub deps: broc_std::BrocDict<u64, broc_std::BrocList<u64>>,
    pub sizes: broc_std::BrocList<u32>,
    pub types: broc_std::BrocList<BrocType>,
    pub typesByName: broc_std::BrocDict<broc_std::BrocStr, u64>,
    pub target: Target,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union BrocType {
    Function: core::mem::ManuallyDrop<R1>,
    Num: BrocNum,
    RecursivePointer: u64,
    BrocBox: u64,
    BrocDict: BrocType_BrocDict,
    BrocList: u64,
    BrocResult: BrocType_BrocResult,
    BrocSet: u64,
    Struct: core::mem::ManuallyDrop<R2>,
    TagUnion: core::mem::ManuallyDrop<BrocTagUnion>,
    TagUnionPayload: core::mem::ManuallyDrop<R14>,
    _sizer: [u8; 104],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R15 {
    pub discriminant: u64,
    pub r#type: u64,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R3 {
    pub name: broc_std::BrocStr,
    pub r#type: u64,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union BrocTagUnion {
    Enumeration: core::mem::ManuallyDrop<R4>,
    NonNullableUnwrapped: core::mem::ManuallyDrop<R5>,
    NonRecursive: core::mem::ManuallyDrop<R6>,
    NullableUnwrapped: core::mem::ManuallyDrop<R8>,
    NullableWrapped: core::mem::ManuallyDrop<R9>,
    Recursive: core::mem::ManuallyDrop<R11>,
    SingleTagStruct: core::mem::ManuallyDrop<R13>,
    _sizer: [u8; 96],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R13 {
    pub name: broc_std::BrocStr,
    pub payloadFields: broc_std::BrocList<u64>,
    pub tagName: broc_std::BrocStr,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R11 {
    pub name: broc_std::BrocStr,
    pub tags: broc_std::BrocList<R12>,
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U4 {
    Some: u64,
    _sizer: [u8; 16],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R9 {
    pub name: broc_std::BrocStr,
    pub tags: broc_std::BrocList<R10>,
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
    pub indexOfNullTag: u16,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U3 {
    Some: u64,
    _sizer: [u8; 16],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R8 {
    pub name: broc_std::BrocStr,
    pub nonNullPayload: u64,
    pub nonNullTag: broc_std::BrocStr,
    pub nullTag: broc_std::BrocStr,
    pub whichTagIsNull: U2,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R6 {
    pub name: broc_std::BrocStr,
    pub tags: broc_std::BrocList<R7>,
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U1 {
    Some: u64,
    _sizer: [u8; 16],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R5 {
    pub name: broc_std::BrocStr,
    pub payload: u64,
    pub tagName: broc_std::BrocStr,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R4 {
    pub name: broc_std::BrocStr,
    pub tags: broc_std::BrocList<broc_std::BrocStr>,
    pub size: u32,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct BrocType_BrocResult {
    pub f0: u64,
    pub f1: u64,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct BrocType_BrocDict {
    pub f0: u64,
    pub f1: u64,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R1 {
    pub args: broc_std::BrocList<u64>,
    pub name: broc_std::BrocStr,
    pub ret: u64,
}

impl BrocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_BrocType {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_BrocType>(*bytes.as_ptr().add(48))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_BrocType) {
        let discriminant_ptr: *mut discriminant_BrocType = (self as *mut BrocType).cast();

        unsafe {
            *(discriminant_ptr.add(48)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Bool, which has no payload.
    pub const Bool: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<BrocType>()];

        bytes[48] = discriminant_BrocType::Bool as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<BrocType>()], BrocType>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Bool tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Bool(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Bool tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Bool(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named EmptyTagUnion, which has no payload.
    pub const EmptyTagUnion: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<BrocType>()];

        bytes[48] = discriminant_BrocType::EmptyTagUnion as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<BrocType>()], BrocType>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the EmptyTagUnion tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_EmptyTagUnion(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the EmptyTagUnion tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_EmptyTagUnion(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Function`, with the appropriate payload
    pub fn Function(arg0: R1) -> Self {
            let mut answer = Self {
                Function: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocType::Function);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `Function` and convert it to `Function`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Function`.
            pub unsafe fn into_Function(mut self) -> R1 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::Function);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Function,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `Function` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Function`.
            pub unsafe fn as_Function(&self) -> &R1 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::Function);
        let payload = &self.Function;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Num`, with the appropriate payload
    pub fn Num(arg: BrocNum) -> Self {
            let mut answer = Self {
                Num: arg
            };

            answer.set_discriminant(discriminant_BrocType::Num);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `Num` and convert it to `Num`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Num`.
            pub unsafe fn into_Num(self) -> BrocNum {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::Num);
        let payload = self.Num;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `Num` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Num`.
            pub unsafe fn as_Num(&self) -> &BrocNum {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::Num);
        let payload = &self.Num;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `RecursivePointer`, with the appropriate payload
    pub fn RecursivePointer(arg: u32) -> Self {
            let mut answer = Self {
                RecursivePointer: arg
            };

            answer.set_discriminant(discriminant_BrocType::RecursivePointer);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `RecursivePointer` and convert it to `RecursivePointer`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `RecursivePointer`.
            pub unsafe fn into_RecursivePointer(self) -> u32 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::RecursivePointer);
        let payload = self.RecursivePointer;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `RecursivePointer` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `RecursivePointer`.
            pub unsafe fn as_RecursivePointer(&self) -> &u32 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::RecursivePointer);
        let payload = &self.RecursivePointer;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `BrocBox`, with the appropriate payload
    pub fn BrocBox(arg: u32) -> Self {
            let mut answer = Self {
                BrocBox: arg
            };

            answer.set_discriminant(discriminant_BrocType::BrocBox);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocBox` and convert it to `BrocBox`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocBox`.
            pub unsafe fn into_BrocBox(self) -> u32 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocBox);
        let payload = self.BrocBox;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocBox` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocBox`.
            pub unsafe fn as_BrocBox(&self) -> &u32 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocBox);
        let payload = &self.BrocBox;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `BrocDict`, with the appropriate payload
    pub fn BrocDict(arg0: u32, arg1: u32) -> Self {
            let mut answer = Self {
                BrocDict: BrocType_BrocDict {
                    f0: arg0,
                    f1: arg1,
                }
            };

            answer.set_discriminant(discriminant_BrocType::BrocDict);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocDict` and convert it to `BrocDict`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocDict`.
            pub unsafe fn into_BrocDict(self) -> (u32, u32) {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocDict);
        let payload = self.BrocDict;

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocDict` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocDict`.
            pub unsafe fn as_BrocDict(&self) -> (&u32, &u32) {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocDict);
        let payload = &self.BrocDict;

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `BrocList`, with the appropriate payload
    pub fn BrocList(arg: u32) -> Self {
            let mut answer = Self {
                BrocList: arg
            };

            answer.set_discriminant(discriminant_BrocType::BrocList);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocList` and convert it to `BrocList`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocList`.
            pub unsafe fn into_BrocList(self) -> u32 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocList);
        let payload = self.BrocList;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocList` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocList`.
            pub unsafe fn as_BrocList(&self) -> &u32 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocList);
        let payload = &self.BrocList;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `BrocResult`, with the appropriate payload
    pub fn BrocResult(arg0: u32, arg1: u32) -> Self {
            let mut answer = Self {
                BrocResult: BrocType_BrocResult {
                    f0: arg0,
                    f1: arg1,
                }
            };

            answer.set_discriminant(discriminant_BrocType::BrocResult);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocResult` and convert it to `BrocResult`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocResult`.
            pub unsafe fn into_BrocResult(self) -> (u32, u32) {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocResult);
        let payload = self.BrocResult;

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocResult` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocResult`.
            pub unsafe fn as_BrocResult(&self) -> (&u32, &u32) {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocResult);
        let payload = &self.BrocResult;

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `BrocSet`, with the appropriate payload
    pub fn BrocSet(arg: u32) -> Self {
            let mut answer = Self {
                BrocSet: arg
            };

            answer.set_discriminant(discriminant_BrocType::BrocSet);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocSet` and convert it to `BrocSet`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocSet`.
            pub unsafe fn into_BrocSet(self) -> u32 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocSet);
        let payload = self.BrocSet;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocSet` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocSet`.
            pub unsafe fn as_BrocSet(&self) -> &u32 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocSet);
        let payload = &self.BrocSet;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named BrocStr, which has no payload.
    pub const BrocStr: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<BrocType>()];

        bytes[48] = discriminant_BrocType::BrocStr as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<BrocType>()], BrocType>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the BrocStr tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_BrocStr(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the BrocStr tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_BrocStr(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Struct`, with the appropriate payload
    pub fn Struct(arg0: R2) -> Self {
            let mut answer = Self {
                Struct: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocType::Struct);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `Struct` and convert it to `Struct`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Struct`.
            pub unsafe fn into_Struct(mut self) -> R2 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::Struct);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Struct,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `Struct` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Struct`.
            pub unsafe fn as_Struct(&self) -> &R2 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::Struct);
        let payload = &self.Struct;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `TagUnion`, with the appropriate payload
    pub fn TagUnion(arg: BrocTagUnion) -> Self {
            let mut answer = Self {
                TagUnion: core::mem::ManuallyDrop::new(arg)
            };

            answer.set_discriminant(discriminant_BrocType::TagUnion);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `TagUnion` and convert it to `TagUnion`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `TagUnion`.
            pub unsafe fn into_TagUnion(mut self) -> BrocTagUnion {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::TagUnion);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.TagUnion,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `TagUnion` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `TagUnion`.
            pub unsafe fn as_TagUnion(&self) -> &BrocTagUnion {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::TagUnion);
        let payload = &self.TagUnion;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `TagUnionPayload`, with the appropriate payload
    pub fn TagUnionPayload(arg0: R14) -> Self {
            let mut answer = Self {
                TagUnionPayload: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocType::TagUnionPayload);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `TagUnionPayload` and convert it to `TagUnionPayload`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `TagUnionPayload`.
            pub unsafe fn into_TagUnionPayload(mut self) -> R14 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::TagUnionPayload);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.TagUnionPayload,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `TagUnionPayload` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `TagUnionPayload`.
            pub unsafe fn as_TagUnionPayload(&self) -> &R14 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::TagUnionPayload);
        let payload = &self.TagUnionPayload;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Unit, which has no payload.
    pub const Unit: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<BrocType>()];

        bytes[48] = discriminant_BrocType::Unit as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<BrocType>()], BrocType>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Unit tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Unit(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Unit tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Unit(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_BrocType {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_BrocType>(*bytes.as_ptr().add(96))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_BrocType) {
        let discriminant_ptr: *mut discriminant_BrocType = (self as *mut BrocType).cast();

        unsafe {
            *(discriminant_ptr.add(96)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Bool, which has no payload.
    pub const Bool: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<BrocType>()];

        bytes[96] = discriminant_BrocType::Bool as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<BrocType>()], BrocType>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named EmptyTagUnion, which has no payload.
    pub const EmptyTagUnion: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<BrocType>()];

        bytes[96] = discriminant_BrocType::EmptyTagUnion as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<BrocType>()], BrocType>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `RecursivePointer`, with the appropriate payload
    pub fn RecursivePointer(arg: u64) -> Self {
            let mut answer = Self {
                RecursivePointer: arg
            };

            answer.set_discriminant(discriminant_BrocType::RecursivePointer);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `RecursivePointer` and convert it to `RecursivePointer`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `RecursivePointer`.
            pub unsafe fn into_RecursivePointer(self) -> u64 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::RecursivePointer);
        let payload = self.RecursivePointer;

        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `RecursivePointer` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `RecursivePointer`.
            pub unsafe fn as_RecursivePointer(&self) -> &u64 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::RecursivePointer);
        let payload = &self.RecursivePointer;

        &payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BrocBox`, with the appropriate payload
    pub fn BrocBox(arg: u64) -> Self {
            let mut answer = Self {
                BrocBox: arg
            };

            answer.set_discriminant(discriminant_BrocType::BrocBox);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocBox` and convert it to `BrocBox`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocBox`.
            pub unsafe fn into_BrocBox(self) -> u64 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocBox);
        let payload = self.BrocBox;

        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocBox` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocBox`.
            pub unsafe fn as_BrocBox(&self) -> &u64 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocBox);
        let payload = &self.BrocBox;

        &payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BrocDict`, with the appropriate payload
    pub fn BrocDict(arg0: u64, arg1: u64) -> Self {
            let mut answer = Self {
                BrocDict: BrocType_BrocDict {
                    f0: arg0,
                    f1: arg1,
                }
            };

            answer.set_discriminant(discriminant_BrocType::BrocDict);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocDict` and convert it to `BrocDict`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocDict`.
            pub unsafe fn into_BrocDict(self) -> (u64, u64) {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocDict);
        let payload = self.BrocDict;

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocDict` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocDict`.
            pub unsafe fn as_BrocDict(&self) -> (&u64, &u64) {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocDict);
        let payload = &self.BrocDict;

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BrocList`, with the appropriate payload
    pub fn BrocList(arg: u64) -> Self {
            let mut answer = Self {
                BrocList: arg
            };

            answer.set_discriminant(discriminant_BrocType::BrocList);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocList` and convert it to `BrocList`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocList`.
            pub unsafe fn into_BrocList(self) -> u64 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocList);
        let payload = self.BrocList;

        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocList` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocList`.
            pub unsafe fn as_BrocList(&self) -> &u64 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocList);
        let payload = &self.BrocList;

        &payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BrocResult`, with the appropriate payload
    pub fn BrocResult(arg0: u64, arg1: u64) -> Self {
            let mut answer = Self {
                BrocResult: BrocType_BrocResult {
                    f0: arg0,
                    f1: arg1,
                }
            };

            answer.set_discriminant(discriminant_BrocType::BrocResult);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocResult` and convert it to `BrocResult`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocResult`.
            pub unsafe fn into_BrocResult(self) -> (u64, u64) {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocResult);
        let payload = self.BrocResult;

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocResult` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocResult`.
            pub unsafe fn as_BrocResult(&self) -> (&u64, &u64) {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocResult);
        let payload = &self.BrocResult;

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BrocSet`, with the appropriate payload
    pub fn BrocSet(arg: u64) -> Self {
            let mut answer = Self {
                BrocSet: arg
            };

            answer.set_discriminant(discriminant_BrocType::BrocSet);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocSet` and convert it to `BrocSet`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocSet`.
            pub unsafe fn into_BrocSet(self) -> u64 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocSet);
        let payload = self.BrocSet;

        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocType` has a `.discriminant()` of `BrocSet` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `BrocSet`.
            pub unsafe fn as_BrocSet(&self) -> &u64 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocType::BrocSet);
        let payload = &self.BrocSet;

        &payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named BrocStr, which has no payload.
    pub const BrocStr: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<BrocType>()];

        bytes[96] = discriminant_BrocType::BrocStr as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<BrocType>()], BrocType>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Unit, which has no payload.
    pub const Unit: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<BrocType>()];

        bytes[96] = discriminant_BrocType::Unit as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<BrocType>()], BrocType>(bytes)
    };
}

impl Drop for BrocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                discriminant_BrocType::Bool => {}
                discriminant_BrocType::EmptyTagUnion => {}
                discriminant_BrocType::Function => unsafe { core::mem::ManuallyDrop::drop(&mut self.Function) },
                discriminant_BrocType::Num => {}
                discriminant_BrocType::RecursivePointer => {}
                discriminant_BrocType::BrocBox => {}
                discriminant_BrocType::BrocDict => {}
                discriminant_BrocType::BrocList => {}
                discriminant_BrocType::BrocResult => {}
                discriminant_BrocType::BrocSet => {}
                discriminant_BrocType::BrocStr => {}
                discriminant_BrocType::Struct => unsafe { core::mem::ManuallyDrop::drop(&mut self.Struct) },
                discriminant_BrocType::TagUnion => unsafe { core::mem::ManuallyDrop::drop(&mut self.TagUnion) },
                discriminant_BrocType::TagUnionPayload => unsafe { core::mem::ManuallyDrop::drop(&mut self.TagUnionPayload) },
                discriminant_BrocType::Unit => {}
            }

    }
}

impl Eq for BrocType {}

impl PartialEq for BrocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_BrocType::Bool => true,
                discriminant_BrocType::EmptyTagUnion => true,
                discriminant_BrocType::Function => self.Function == other.Function,
                discriminant_BrocType::Num => self.Num == other.Num,
                discriminant_BrocType::RecursivePointer => self.RecursivePointer == other.RecursivePointer,
                discriminant_BrocType::BrocBox => self.BrocBox == other.BrocBox,
                discriminant_BrocType::BrocDict => self.BrocDict == other.BrocDict,
                discriminant_BrocType::BrocList => self.BrocList == other.BrocList,
                discriminant_BrocType::BrocResult => self.BrocResult == other.BrocResult,
                discriminant_BrocType::BrocSet => self.BrocSet == other.BrocSet,
                discriminant_BrocType::BrocStr => true,
                discriminant_BrocType::Struct => self.Struct == other.Struct,
                discriminant_BrocType::TagUnion => self.TagUnion == other.TagUnion,
                discriminant_BrocType::TagUnionPayload => self.TagUnionPayload == other.TagUnionPayload,
                discriminant_BrocType::Unit => true,
            }
        }
    }
}

impl PartialOrd for BrocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_BrocType::Bool => Some(core::cmp::Ordering::Equal),
                discriminant_BrocType::EmptyTagUnion => Some(core::cmp::Ordering::Equal),
                discriminant_BrocType::Function => self.Function.partial_cmp(&other.Function),
                discriminant_BrocType::Num => self.Num.partial_cmp(&other.Num),
                discriminant_BrocType::RecursivePointer => self.RecursivePointer.partial_cmp(&other.RecursivePointer),
                discriminant_BrocType::BrocBox => self.BrocBox.partial_cmp(&other.BrocBox),
                discriminant_BrocType::BrocDict => self.BrocDict.partial_cmp(&other.BrocDict),
                discriminant_BrocType::BrocList => self.BrocList.partial_cmp(&other.BrocList),
                discriminant_BrocType::BrocResult => self.BrocResult.partial_cmp(&other.BrocResult),
                discriminant_BrocType::BrocSet => self.BrocSet.partial_cmp(&other.BrocSet),
                discriminant_BrocType::BrocStr => Some(core::cmp::Ordering::Equal),
                discriminant_BrocType::Struct => self.Struct.partial_cmp(&other.Struct),
                discriminant_BrocType::TagUnion => self.TagUnion.partial_cmp(&other.TagUnion),
                discriminant_BrocType::TagUnionPayload => self.TagUnionPayload.partial_cmp(&other.TagUnionPayload),
                discriminant_BrocType::Unit => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for BrocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_BrocType::Bool => core::cmp::Ordering::Equal,
                discriminant_BrocType::EmptyTagUnion => core::cmp::Ordering::Equal,
                discriminant_BrocType::Function => self.Function.cmp(&other.Function),
                discriminant_BrocType::Num => self.Num.cmp(&other.Num),
                discriminant_BrocType::RecursivePointer => self.RecursivePointer.cmp(&other.RecursivePointer),
                discriminant_BrocType::BrocBox => self.BrocBox.cmp(&other.BrocBox),
                discriminant_BrocType::BrocDict => self.BrocDict.cmp(&other.BrocDict),
                discriminant_BrocType::BrocList => self.BrocList.cmp(&other.BrocList),
                discriminant_BrocType::BrocResult => self.BrocResult.cmp(&other.BrocResult),
                discriminant_BrocType::BrocSet => self.BrocSet.cmp(&other.BrocSet),
                discriminant_BrocType::BrocStr => core::cmp::Ordering::Equal,
                discriminant_BrocType::Struct => self.Struct.cmp(&other.Struct),
                discriminant_BrocType::TagUnion => self.TagUnion.cmp(&other.TagUnion),
                discriminant_BrocType::TagUnionPayload => self.TagUnionPayload.cmp(&other.TagUnionPayload),
                discriminant_BrocType::Unit => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Clone for BrocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_BrocType::Bool => core::mem::transmute::<
                    core::mem::MaybeUninit<BrocType>,
                    BrocType,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_BrocType::EmptyTagUnion => core::mem::transmute::<
                    core::mem::MaybeUninit<BrocType>,
                    BrocType,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_BrocType::Function => Self {
                    Function: self.Function.clone(),
                },
                discriminant_BrocType::Num => Self {
                    Num: self.Num.clone(),
                },
                discriminant_BrocType::RecursivePointer => Self {
                    RecursivePointer: self.RecursivePointer.clone(),
                },
                discriminant_BrocType::BrocBox => Self {
                    BrocBox: self.BrocBox.clone(),
                },
                discriminant_BrocType::BrocDict => Self {
                    BrocDict: self.BrocDict.clone(),
                },
                discriminant_BrocType::BrocList => Self {
                    BrocList: self.BrocList.clone(),
                },
                discriminant_BrocType::BrocResult => Self {
                    BrocResult: self.BrocResult.clone(),
                },
                discriminant_BrocType::BrocSet => Self {
                    BrocSet: self.BrocSet.clone(),
                },
                discriminant_BrocType::BrocStr => core::mem::transmute::<
                    core::mem::MaybeUninit<BrocType>,
                    BrocType,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_BrocType::Struct => Self {
                    Struct: self.Struct.clone(),
                },
                discriminant_BrocType::TagUnion => Self {
                    TagUnion: self.TagUnion.clone(),
                },
                discriminant_BrocType::TagUnionPayload => Self {
                    TagUnionPayload: self.TagUnionPayload.clone(),
                },
                discriminant_BrocType::Unit => core::mem::transmute::<
                    core::mem::MaybeUninit<BrocType>,
                    BrocType,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for BrocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_BrocType::Bool => discriminant_BrocType::Bool.hash(state),
            discriminant_BrocType::EmptyTagUnion => discriminant_BrocType::EmptyTagUnion.hash(state),
            discriminant_BrocType::Function => unsafe {
                    discriminant_BrocType::Function.hash(state);
                    self.Function.hash(state);
                },
            discriminant_BrocType::Num => unsafe {
                    discriminant_BrocType::Num.hash(state);
                    self.Num.hash(state);
                },
            discriminant_BrocType::RecursivePointer => unsafe {
                    discriminant_BrocType::RecursivePointer.hash(state);
                    self.RecursivePointer.hash(state);
                },
            discriminant_BrocType::BrocBox => unsafe {
                    discriminant_BrocType::BrocBox.hash(state);
                    self.BrocBox.hash(state);
                },
            discriminant_BrocType::BrocDict => unsafe {
                    discriminant_BrocType::BrocDict.hash(state);
                    self.BrocDict.hash(state);
                },
            discriminant_BrocType::BrocList => unsafe {
                    discriminant_BrocType::BrocList.hash(state);
                    self.BrocList.hash(state);
                },
            discriminant_BrocType::BrocResult => unsafe {
                    discriminant_BrocType::BrocResult.hash(state);
                    self.BrocResult.hash(state);
                },
            discriminant_BrocType::BrocSet => unsafe {
                    discriminant_BrocType::BrocSet.hash(state);
                    self.BrocSet.hash(state);
                },
            discriminant_BrocType::BrocStr => discriminant_BrocType::BrocStr.hash(state),
            discriminant_BrocType::Struct => unsafe {
                    discriminant_BrocType::Struct.hash(state);
                    self.Struct.hash(state);
                },
            discriminant_BrocType::TagUnion => unsafe {
                    discriminant_BrocType::TagUnion.hash(state);
                    self.TagUnion.hash(state);
                },
            discriminant_BrocType::TagUnionPayload => unsafe {
                    discriminant_BrocType::TagUnionPayload.hash(state);
                    self.TagUnionPayload.hash(state);
                },
            discriminant_BrocType::Unit => discriminant_BrocType::Unit.hash(state),
        }
    }
}

impl core::fmt::Debug for BrocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("BrocType::")?;

        unsafe {
            match self.discriminant() {
                discriminant_BrocType::Bool => f.write_str("Bool"),
                discriminant_BrocType::EmptyTagUnion => f.write_str("EmptyTagUnion"),
                discriminant_BrocType::Function => f.debug_tuple("Function")
        .field(&*self.Function)
        .finish(),
                discriminant_BrocType::Num => f.debug_tuple("Num")
        .field(&self.Num)
        .finish(),
                discriminant_BrocType::RecursivePointer => f.debug_tuple("RecursivePointer")
        .field(&self.RecursivePointer)
        .finish(),
                discriminant_BrocType::BrocBox => f.debug_tuple("BrocBox")
        .field(&self.BrocBox)
        .finish(),
                discriminant_BrocType::BrocDict => f.debug_tuple("BrocDict")
        .field(&(&self.BrocDict).f0)
.field(&(&self.BrocDict).f1)
        .finish(),
                discriminant_BrocType::BrocList => f.debug_tuple("BrocList")
        .field(&self.BrocList)
        .finish(),
                discriminant_BrocType::BrocResult => f.debug_tuple("BrocResult")
        .field(&(&self.BrocResult).f0)
.field(&(&self.BrocResult).f1)
        .finish(),
                discriminant_BrocType::BrocSet => f.debug_tuple("BrocSet")
        .field(&self.BrocSet)
        .finish(),
                discriminant_BrocType::BrocStr => f.write_str("BrocStr"),
                discriminant_BrocType::Struct => f.debug_tuple("Struct")
        .field(&*self.Struct)
        .finish(),
                discriminant_BrocType::TagUnion => f.debug_tuple("TagUnion")
        .field(&*self.TagUnion)
        .finish(),
                discriminant_BrocType::TagUnionPayload => f.debug_tuple("TagUnionPayload")
        .field(&*self.TagUnionPayload)
        .finish(),
                discriminant_BrocType::Unit => f.write_str("Unit"),
            }
        }
    }
}

impl BrocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_BrocTagUnion {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_BrocTagUnion>(*bytes.as_ptr().add(44))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_BrocTagUnion) {
        let discriminant_ptr: *mut discriminant_BrocTagUnion = (self as *mut BrocTagUnion).cast();

        unsafe {
            *(discriminant_ptr.add(44)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Enumeration`, with the appropriate payload
    pub fn Enumeration(arg0: R4) -> Self {
            let mut answer = Self {
                Enumeration: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocTagUnion::Enumeration);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `Enumeration` and convert it to `Enumeration`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Enumeration`.
            pub unsafe fn into_Enumeration(mut self) -> R4 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::Enumeration);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Enumeration,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `Enumeration` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Enumeration`.
            pub unsafe fn as_Enumeration(&self) -> &R4 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::Enumeration);
        let payload = &self.Enumeration;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `NonNullableUnwrapped`, with the appropriate payload
    pub fn NonNullableUnwrapped(arg0: R5) -> Self {
            let mut answer = Self {
                NonNullableUnwrapped: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocTagUnion::NonNullableUnwrapped);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `NonNullableUnwrapped` and convert it to `NonNullableUnwrapped`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `NonNullableUnwrapped`.
            pub unsafe fn into_NonNullableUnwrapped(mut self) -> R5 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::NonNullableUnwrapped);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.NonNullableUnwrapped,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `NonNullableUnwrapped` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `NonNullableUnwrapped`.
            pub unsafe fn as_NonNullableUnwrapped(&self) -> &R5 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::NonNullableUnwrapped);
        let payload = &self.NonNullableUnwrapped;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `NonRecursive`, with the appropriate payload
    pub fn NonRecursive(arg0: R6) -> Self {
            let mut answer = Self {
                NonRecursive: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocTagUnion::NonRecursive);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `NonRecursive` and convert it to `NonRecursive`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `NonRecursive`.
            pub unsafe fn into_NonRecursive(mut self) -> R6 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::NonRecursive);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.NonRecursive,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `NonRecursive` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `NonRecursive`.
            pub unsafe fn as_NonRecursive(&self) -> &R6 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::NonRecursive);
        let payload = &self.NonRecursive;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `NullableUnwrapped`, with the appropriate payload
    pub fn NullableUnwrapped(arg0: R8) -> Self {
            let mut answer = Self {
                NullableUnwrapped: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocTagUnion::NullableUnwrapped);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `NullableUnwrapped` and convert it to `NullableUnwrapped`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `NullableUnwrapped`.
            pub unsafe fn into_NullableUnwrapped(mut self) -> R8 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::NullableUnwrapped);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.NullableUnwrapped,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `NullableUnwrapped` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `NullableUnwrapped`.
            pub unsafe fn as_NullableUnwrapped(&self) -> &R8 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::NullableUnwrapped);
        let payload = &self.NullableUnwrapped;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `NullableWrapped`, with the appropriate payload
    pub fn NullableWrapped(arg0: R9) -> Self {
            let mut answer = Self {
                NullableWrapped: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocTagUnion::NullableWrapped);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `NullableWrapped` and convert it to `NullableWrapped`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `NullableWrapped`.
            pub unsafe fn into_NullableWrapped(mut self) -> R9 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::NullableWrapped);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.NullableWrapped,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `NullableWrapped` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `NullableWrapped`.
            pub unsafe fn as_NullableWrapped(&self) -> &R9 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::NullableWrapped);
        let payload = &self.NullableWrapped;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Recursive`, with the appropriate payload
    pub fn Recursive(arg0: R11) -> Self {
            let mut answer = Self {
                Recursive: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocTagUnion::Recursive);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `Recursive` and convert it to `Recursive`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Recursive`.
            pub unsafe fn into_Recursive(mut self) -> R11 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::Recursive);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Recursive,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `Recursive` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Recursive`.
            pub unsafe fn as_Recursive(&self) -> &R11 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::Recursive);
        let payload = &self.Recursive;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `SingleTagStruct`, with the appropriate payload
    pub fn SingleTagStruct(arg0: R13) -> Self {
            let mut answer = Self {
                SingleTagStruct: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_BrocTagUnion::SingleTagStruct);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `SingleTagStruct` and convert it to `SingleTagStruct`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `SingleTagStruct`.
            pub unsafe fn into_SingleTagStruct(mut self) -> R13 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::SingleTagStruct);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.SingleTagStruct,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `BrocTagUnion` has a `.discriminant()` of `SingleTagStruct` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `SingleTagStruct`.
            pub unsafe fn as_SingleTagStruct(&self) -> &R13 {
                debug_assert_eq!(self.discriminant(), discriminant_BrocTagUnion::SingleTagStruct);
        let payload = &self.SingleTagStruct;

        
        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_BrocTagUnion {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_BrocTagUnion>(*bytes.as_ptr().add(88))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_BrocTagUnion) {
        let discriminant_ptr: *mut discriminant_BrocTagUnion = (self as *mut BrocTagUnion).cast();

        unsafe {
            *(discriminant_ptr.add(88)) = discriminant;
        }
    }
}

impl Drop for BrocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                discriminant_BrocTagUnion::Enumeration => unsafe { core::mem::ManuallyDrop::drop(&mut self.Enumeration) },
                discriminant_BrocTagUnion::NonNullableUnwrapped => unsafe { core::mem::ManuallyDrop::drop(&mut self.NonNullableUnwrapped) },
                discriminant_BrocTagUnion::NonRecursive => unsafe { core::mem::ManuallyDrop::drop(&mut self.NonRecursive) },
                discriminant_BrocTagUnion::NullableUnwrapped => unsafe { core::mem::ManuallyDrop::drop(&mut self.NullableUnwrapped) },
                discriminant_BrocTagUnion::NullableWrapped => unsafe { core::mem::ManuallyDrop::drop(&mut self.NullableWrapped) },
                discriminant_BrocTagUnion::Recursive => unsafe { core::mem::ManuallyDrop::drop(&mut self.Recursive) },
                discriminant_BrocTagUnion::SingleTagStruct => unsafe { core::mem::ManuallyDrop::drop(&mut self.SingleTagStruct) },
            }

    }
}

impl Eq for BrocTagUnion {}

impl PartialEq for BrocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_BrocTagUnion::Enumeration => self.Enumeration == other.Enumeration,
                discriminant_BrocTagUnion::NonNullableUnwrapped => self.NonNullableUnwrapped == other.NonNullableUnwrapped,
                discriminant_BrocTagUnion::NonRecursive => self.NonRecursive == other.NonRecursive,
                discriminant_BrocTagUnion::NullableUnwrapped => self.NullableUnwrapped == other.NullableUnwrapped,
                discriminant_BrocTagUnion::NullableWrapped => self.NullableWrapped == other.NullableWrapped,
                discriminant_BrocTagUnion::Recursive => self.Recursive == other.Recursive,
                discriminant_BrocTagUnion::SingleTagStruct => self.SingleTagStruct == other.SingleTagStruct,
            }
        }
    }
}

impl PartialOrd for BrocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_BrocTagUnion::Enumeration => self.Enumeration.partial_cmp(&other.Enumeration),
                discriminant_BrocTagUnion::NonNullableUnwrapped => self.NonNullableUnwrapped.partial_cmp(&other.NonNullableUnwrapped),
                discriminant_BrocTagUnion::NonRecursive => self.NonRecursive.partial_cmp(&other.NonRecursive),
                discriminant_BrocTagUnion::NullableUnwrapped => self.NullableUnwrapped.partial_cmp(&other.NullableUnwrapped),
                discriminant_BrocTagUnion::NullableWrapped => self.NullableWrapped.partial_cmp(&other.NullableWrapped),
                discriminant_BrocTagUnion::Recursive => self.Recursive.partial_cmp(&other.Recursive),
                discriminant_BrocTagUnion::SingleTagStruct => self.SingleTagStruct.partial_cmp(&other.SingleTagStruct),
            }
        }
    }
}

impl Ord for BrocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_BrocTagUnion::Enumeration => self.Enumeration.cmp(&other.Enumeration),
                discriminant_BrocTagUnion::NonNullableUnwrapped => self.NonNullableUnwrapped.cmp(&other.NonNullableUnwrapped),
                discriminant_BrocTagUnion::NonRecursive => self.NonRecursive.cmp(&other.NonRecursive),
                discriminant_BrocTagUnion::NullableUnwrapped => self.NullableUnwrapped.cmp(&other.NullableUnwrapped),
                discriminant_BrocTagUnion::NullableWrapped => self.NullableWrapped.cmp(&other.NullableWrapped),
                discriminant_BrocTagUnion::Recursive => self.Recursive.cmp(&other.Recursive),
                discriminant_BrocTagUnion::SingleTagStruct => self.SingleTagStruct.cmp(&other.SingleTagStruct),
            }
        }
    }
}

impl Clone for BrocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_BrocTagUnion::Enumeration => Self {
                    Enumeration: self.Enumeration.clone(),
                },
                discriminant_BrocTagUnion::NonNullableUnwrapped => Self {
                    NonNullableUnwrapped: self.NonNullableUnwrapped.clone(),
                },
                discriminant_BrocTagUnion::NonRecursive => Self {
                    NonRecursive: self.NonRecursive.clone(),
                },
                discriminant_BrocTagUnion::NullableUnwrapped => Self {
                    NullableUnwrapped: self.NullableUnwrapped.clone(),
                },
                discriminant_BrocTagUnion::NullableWrapped => Self {
                    NullableWrapped: self.NullableWrapped.clone(),
                },
                discriminant_BrocTagUnion::Recursive => Self {
                    Recursive: self.Recursive.clone(),
                },
                discriminant_BrocTagUnion::SingleTagStruct => Self {
                    SingleTagStruct: self.SingleTagStruct.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for BrocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_BrocTagUnion::Enumeration => unsafe {
                    discriminant_BrocTagUnion::Enumeration.hash(state);
                    self.Enumeration.hash(state);
                },
            discriminant_BrocTagUnion::NonNullableUnwrapped => unsafe {
                    discriminant_BrocTagUnion::NonNullableUnwrapped.hash(state);
                    self.NonNullableUnwrapped.hash(state);
                },
            discriminant_BrocTagUnion::NonRecursive => unsafe {
                    discriminant_BrocTagUnion::NonRecursive.hash(state);
                    self.NonRecursive.hash(state);
                },
            discriminant_BrocTagUnion::NullableUnwrapped => unsafe {
                    discriminant_BrocTagUnion::NullableUnwrapped.hash(state);
                    self.NullableUnwrapped.hash(state);
                },
            discriminant_BrocTagUnion::NullableWrapped => unsafe {
                    discriminant_BrocTagUnion::NullableWrapped.hash(state);
                    self.NullableWrapped.hash(state);
                },
            discriminant_BrocTagUnion::Recursive => unsafe {
                    discriminant_BrocTagUnion::Recursive.hash(state);
                    self.Recursive.hash(state);
                },
            discriminant_BrocTagUnion::SingleTagStruct => unsafe {
                    discriminant_BrocTagUnion::SingleTagStruct.hash(state);
                    self.SingleTagStruct.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for BrocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("BrocTagUnion::")?;

        unsafe {
            match self.discriminant() {
                discriminant_BrocTagUnion::Enumeration => f.debug_tuple("Enumeration")
        .field(&*self.Enumeration)
        .finish(),
                discriminant_BrocTagUnion::NonNullableUnwrapped => f.debug_tuple("NonNullableUnwrapped")
        .field(&*self.NonNullableUnwrapped)
        .finish(),
                discriminant_BrocTagUnion::NonRecursive => f.debug_tuple("NonRecursive")
        .field(&*self.NonRecursive)
        .finish(),
                discriminant_BrocTagUnion::NullableUnwrapped => f.debug_tuple("NullableUnwrapped")
        .field(&*self.NullableUnwrapped)
        .finish(),
                discriminant_BrocTagUnion::NullableWrapped => f.debug_tuple("NullableWrapped")
        .field(&*self.NullableWrapped)
        .finish(),
                discriminant_BrocTagUnion::Recursive => f.debug_tuple("Recursive")
        .field(&*self.Recursive)
        .finish(),
                discriminant_BrocTagUnion::SingleTagStruct => f.debug_tuple("SingleTagStruct")
        .field(&*self.SingleTagStruct)
        .finish(),
            }
        }
    }
}

impl U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U4 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U4>(*bytes.as_ptr().add(4))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U4) {
        let discriminant_ptr: *mut discriminant_U4 = (self as *mut U4).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<U4>()];

        bytes[4] = discriminant_U4::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<U4>()], U4>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_None(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_None(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `Some`, with the appropriate payload
    pub fn Some(arg: u32) -> Self {
            let mut answer = Self {
                Some: arg
            };

            answer.set_discriminant(discriminant_U4::Some);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `U4` has a `.discriminant()` of `Some` and convert it to `Some`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn into_Some(self) -> u32 {
                debug_assert_eq!(self.discriminant(), discriminant_U4::Some);
        let payload = self.Some;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `U4` has a `.discriminant()` of `Some` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn as_Some(&self) -> &u32 {
                debug_assert_eq!(self.discriminant(), discriminant_U4::Some);
        let payload = &self.Some;

        &payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U4 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U4>(*bytes.as_ptr().add(8))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U4) {
        let discriminant_ptr: *mut discriminant_U4 = (self as *mut U4).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<U4>()];

        bytes[8] = discriminant_U4::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<U4>()], U4>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Some`, with the appropriate payload
    pub fn Some(arg: u64) -> Self {
            let mut answer = Self {
                Some: arg
            };

            answer.set_discriminant(discriminant_U4::Some);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U4` has a `.discriminant()` of `Some` and convert it to `Some`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn into_Some(self) -> u64 {
                debug_assert_eq!(self.discriminant(), discriminant_U4::Some);
        let payload = self.Some;

        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U4` has a `.discriminant()` of `Some` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn as_Some(&self) -> &u64 {
                debug_assert_eq!(self.discriminant(), discriminant_U4::Some);
        let payload = &self.Some;

        &payload
    }
}

impl Eq for U4 {}

impl PartialEq for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_U4::None => true,
                discriminant_U4::Some => self.Some == other.Some,
            }
        }
    }
}

impl PartialOrd for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U4::None => Some(core::cmp::Ordering::Equal),
                discriminant_U4::Some => self.Some.partial_cmp(&other.Some),
            }
        }
    }
}

impl Ord for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_U4::None => core::cmp::Ordering::Equal,
                discriminant_U4::Some => self.Some.cmp(&other.Some),
            }
        }
    }
}

impl Copy for U4 {}

impl Clone for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U4::None => core::mem::transmute::<
                    core::mem::MaybeUninit<U4>,
                    U4,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_U4::Some => Self {
                    Some: self.Some.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_U4::None => discriminant_U4::None.hash(state),
            discriminant_U4::Some => unsafe {
                    discriminant_U4::Some.hash(state);
                    self.Some.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U4::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U4::None => f.write_str("None"),
                discriminant_U4::Some => f.debug_tuple("Some")
        .field(&self.Some)
        .finish(),
            }
        }
    }
}

impl U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U3 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U3>(*bytes.as_ptr().add(4))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U3) {
        let discriminant_ptr: *mut discriminant_U3 = (self as *mut U3).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<U3>()];

        bytes[4] = discriminant_U3::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<U3>()], U3>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_None(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_None(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `Some`, with the appropriate payload
    pub fn Some(arg: u32) -> Self {
            let mut answer = Self {
                Some: arg
            };

            answer.set_discriminant(discriminant_U3::Some);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `U3` has a `.discriminant()` of `Some` and convert it to `Some`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn into_Some(self) -> u32 {
                debug_assert_eq!(self.discriminant(), discriminant_U3::Some);
        let payload = self.Some;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `U3` has a `.discriminant()` of `Some` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn as_Some(&self) -> &u32 {
                debug_assert_eq!(self.discriminant(), discriminant_U3::Some);
        let payload = &self.Some;

        &payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U3 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U3>(*bytes.as_ptr().add(8))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U3) {
        let discriminant_ptr: *mut discriminant_U3 = (self as *mut U3).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<U3>()];

        bytes[8] = discriminant_U3::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<U3>()], U3>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Some`, with the appropriate payload
    pub fn Some(arg: u64) -> Self {
            let mut answer = Self {
                Some: arg
            };

            answer.set_discriminant(discriminant_U3::Some);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U3` has a `.discriminant()` of `Some` and convert it to `Some`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn into_Some(self) -> u64 {
                debug_assert_eq!(self.discriminant(), discriminant_U3::Some);
        let payload = self.Some;

        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U3` has a `.discriminant()` of `Some` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn as_Some(&self) -> &u64 {
                debug_assert_eq!(self.discriminant(), discriminant_U3::Some);
        let payload = &self.Some;

        &payload
    }
}

impl Eq for U3 {}

impl PartialEq for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_U3::None => true,
                discriminant_U3::Some => self.Some == other.Some,
            }
        }
    }
}

impl PartialOrd for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U3::None => Some(core::cmp::Ordering::Equal),
                discriminant_U3::Some => self.Some.partial_cmp(&other.Some),
            }
        }
    }
}

impl Ord for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_U3::None => core::cmp::Ordering::Equal,
                discriminant_U3::Some => self.Some.cmp(&other.Some),
            }
        }
    }
}

impl Copy for U3 {}

impl Clone for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U3::None => core::mem::transmute::<
                    core::mem::MaybeUninit<U3>,
                    U3,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_U3::Some => Self {
                    Some: self.Some.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_U3::None => discriminant_U3::None.hash(state),
            discriminant_U3::Some => unsafe {
                    discriminant_U3::Some.hash(state);
                    self.Some.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U3::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U3::None => f.write_str("None"),
                discriminant_U3::Some => f.debug_tuple("Some")
        .field(&self.Some)
        .finish(),
            }
        }
    }
}

impl U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U1 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U1>(*bytes.as_ptr().add(4))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U1) {
        let discriminant_ptr: *mut discriminant_U1 = (self as *mut U1).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<U1>()];

        bytes[4] = discriminant_U1::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<U1>()], U1>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_None(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_None(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Construct a tag named `Some`, with the appropriate payload
    pub fn Some(arg: u32) -> Self {
            let mut answer = Self {
                Some: arg
            };

            answer.set_discriminant(discriminant_U1::Some);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `Some` and convert it to `Some`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn into_Some(self) -> u32 {
                debug_assert_eq!(self.discriminant(), discriminant_U1::Some);
        let payload = self.Some;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `Some` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn as_Some(&self) -> &u32 {
                debug_assert_eq!(self.discriminant(), discriminant_U1::Some);
        let payload = &self.Some;

        &payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U1 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U1>(*bytes.as_ptr().add(8))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U1) {
        let discriminant_ptr: *mut discriminant_U1 = (self as *mut U1).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<U1>()];

        bytes[8] = discriminant_U1::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<U1>()], U1>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Some`, with the appropriate payload
    pub fn Some(arg: u64) -> Self {
            let mut answer = Self {
                Some: arg
            };

            answer.set_discriminant(discriminant_U1::Some);

            answer
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `Some` and convert it to `Some`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn into_Some(self) -> u64 {
                debug_assert_eq!(self.discriminant(), discriminant_U1::Some);
        let payload = self.Some;

        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `Some` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
            pub unsafe fn as_Some(&self) -> &u64 {
                debug_assert_eq!(self.discriminant(), discriminant_U1::Some);
        let payload = &self.Some;

        &payload
    }
}

impl Eq for U1 {}

impl PartialEq for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_U1::None => true,
                discriminant_U1::Some => self.Some == other.Some,
            }
        }
    }
}

impl PartialOrd for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U1::None => Some(core::cmp::Ordering::Equal),
                discriminant_U1::Some => self.Some.partial_cmp(&other.Some),
            }
        }
    }
}

impl Ord for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_U1::None => core::cmp::Ordering::Equal,
                discriminant_U1::Some => self.Some.cmp(&other.Some),
            }
        }
    }
}

impl Copy for U1 {}

impl Clone for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U1::None => core::mem::transmute::<
                    core::mem::MaybeUninit<U1>,
                    U1,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_U1::Some => Self {
                    Some: self.Some.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_U1::None => discriminant_U1::None.hash(state),
            discriminant_U1::Some => unsafe {
                    discriminant_U1::Some.hash(state);
                    self.Some.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U1::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U1::None => f.write_str("None"),
                discriminant_U1::Some => f.debug_tuple("Some")
        .field(&self.Some)
        .finish(),
            }
        }
    }
}
